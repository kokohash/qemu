"use strict";
/*
 * This file is part of the xPack project (http://xpack.github.io).
 * Copyright (c) 2021 Liviu Ionescu. All rights reserved.
 *
 * Licensed under the terms of the MIT License.
 * See LICENSE in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.XpmLiquid = exports.filterWin32Path = exports.filterPosixPath = exports.filterPath = void 0;
/* eslint max-len: [ "error", 80, { "ignoreUrls": true } ] */
// ----------------------------------------------------------------------------
/*
 * This module includes the LiquidJS code used to perform
 * substitutions in xpm and related (like the VS Code extensions).
 *
 * The main code is the map used for substitutions and the list
 * of custom tags.
 */
// ----------------------------------------------------------------------------
const assert = require("assert");
const os = require("os");
const path = require("path");
const process = require("process");
const util = require("util");
// https://www.npmjs.com/package/liquidjs
const liquidjs_1 = require("liquidjs");
// ----------------------------------------------------------------------------
// General purpose functions.
function _isPrimitive(value) {
    return (typeof value !== 'object' && typeof value !== 'function') ||
        value === null;
}
function _isJsonObject(value) {
    return value !== undefined && !_isPrimitive(value) && !Array.isArray(value);
}
function _joinMultiLineProperties(properties) {
    const result = {};
    Object.entries(properties).forEach(([key, value]) => {
        result[key] = Array.isArray(value) ? value.join(os.EOL) : value;
    });
    return result;
}
/**
 * Replace non alphanumeric chars with dashes to make the paths
 * comply with filesystem names.
 *
 * @param {string} input A path candidate.
 * @returns {string} A validated path.
 */
function filterPath(input) {
    /* istanbul ignore next */
    const fixed = (os.platform() === 'win32')
        ? input.replace(/[^a-zA-Z0-9\\:]+/g, '-')
        : input.replace(/[^a-zA-Z0-9/]+/g, '-');
    return fixed.replace(/--/g, '-');
}
exports.filterPath = filterPath;
/**
 * Replace non alphanumeric chars with dashes to make the paths
 * comply with Posix filesystem names.
 *
 * @param {string} input A path candidate.
 * @returns {string} A validated path.
 */
function filterPosixPath(input) {
    /* istanbul ignore next */
    const fixed = input.replace(/[^a-zA-Z0-9/]+/g, '-');
    return fixed.replace(/--/g, '-');
}
exports.filterPosixPath = filterPosixPath;
/**
 * Replace non alphanumeric chars with dashes to make the paths
 * comply with Windows filesystem names.
 *
 * @param {string} input A path candidate.
 * @returns {string} A validated path.
 */
function filterWin32Path(input) {
    /* istanbul ignore next */
    const fixed = input.replace(/[^a-zA-Z0-9\\:]+/g, '-');
    return fixed.replace(/--/g, '-');
}
exports.filterWin32Path = filterWin32Path;
// ============================================================================
// https://liquidjs.com/
class XpmLiquid {
    // --------------------------------------------------------------------------
    // Constructor.
    constructor(log) {
        this.log = log;
        this.engine = new liquidjs_1.Liquid({
            strictFilters: true,
            strictVariables: true,
            trimTagLeft: false,
            trimTagRight: false,
            trimOutputLeft: false,
            trimOutputRight: false,
            greedy: false
        });
        // https://liquidjs.com/api/classes/liquid_.liquid.html#registerFilter
        // https://nodejs.org/dist/latest-v14.x/docs/api/path.html
        // Add the main path manipulation functions.
        this.engine.registerFilter('path_basename', (p, ...arg) => path.basename(p, ...arg));
        this.engine.registerFilter('path_dirname', (p) => path.dirname(p));
        this.engine.registerFilter('path_normalize', (p) => path.normalize(p));
        this.engine.registerFilter('path_join', (p, ...args) => path.join(p, ...args));
        this.engine.registerFilter('path_relative', (from, to) => path.relative(from, to));
        this.engine.registerFilter('path_posix_basename', (p, ...arg) => path.posix.basename(p, ...arg));
        this.engine.registerFilter('path_posix_dirname', (p) => path.posix.dirname(p));
        this.engine.registerFilter('path_posix_normalize', (p) => path.posix.normalize(p));
        this.engine.registerFilter('path_posix_join', (p, ...args) => path.posix.join(p, ...args));
        this.engine.registerFilter('path_posix_relative', (from, to) => path.posix.relative(from, to));
        this.engine.registerFilter('path_win32_basename', (p, ...arg) => path.win32.basename(p, ...arg));
        this.engine.registerFilter('path_win32_dirname', (p) => path.win32.dirname(p));
        this.engine.registerFilter('path_win32_normalize', (p) => path.win32.normalize(p));
        this.engine.registerFilter('path_win32_join', (p, ...args) => path.win32.join(p, ...args));
        this.engine.registerFilter('path_win32_relative', (from, to) => path.win32.relative(from, to));
        // https://nodejs.org/dist/latest-v14.x/docs/api/util.html
        this.engine.registerFilter('util_format', (format, ...args) => {
            // console.log([...args])
            return util.format(format, ...args);
        });
        // Custom action.
        this.engine.registerFilter('to_filename', (p) => filterPath(p));
    }
    // --------------------------------------------------------------------------
    // Methods.
    /**
     * Return the base for a liquid map.
     *
     * @returns A map of properties.
     */
    prepareMap(packageJson, buildConfigurationName) {
        assert(packageJson);
        const liquidMap = {
            env: process.env,
            os: {
                EOL: os.EOL,
                arch: os.arch(),
                constants: {
                    signals: os.constants.signals,
                    errno: os.constants.errno
                },
                cpus: os.cpus(),
                endianness: os.endianness(),
                homedir: os.homedir(),
                hostname: os.hostname(),
                platform: os.platform(),
                release: os.release(),
                tmpdir: os.tmpdir(),
                type: os.type(),
                // os.version() available since 12.x
                version: (typeof os.version === 'function')
                    /* istanbul ignore next */
                    ? os.version()
                    /* istanbul ignore next */
                    : '(unavailable)'
            },
            path: {
                delimiter: path.delimiter,
                sep: path.sep,
                win32: {
                    delimiter: path.win32.delimiter,
                    sep: path.win32.sep
                },
                posix: {
                    delimiter: path.posix.delimiter,
                    sep: path.posix.sep
                }
            },
            package: packageJson
        };
        liquidMap.properties = {};
        if (_isJsonObject(packageJson.xpack)) {
            if (_isJsonObject(packageJson.xpack.properties)) {
                liquidMap.properties =
                    _joinMultiLineProperties(packageJson.xpack.properties);
            }
            if (buildConfigurationName !== undefined &&
                buildConfigurationName !== null &&
                buildConfigurationName.trim() !== '') {
                if (packageJson.xpack.buildConfigurations === undefined) {
                    throw new Error('package.json has no buildConfigurations');
                }
                const buildConfiguration = packageJson.xpack.buildConfigurations[buildConfigurationName];
                if (buildConfiguration === undefined) {
                    throw new Error('package.json has no buildConfiguration.' +
                        `${buildConfigurationName}`);
                }
                liquidMap.configuration = {
                    ...buildConfiguration,
                    name: buildConfigurationName
                };
                if (_isJsonObject(buildConfiguration.properties)) {
                    liquidMap.properties = {
                        ...liquidMap.properties,
                        ...(_joinMultiLineProperties(buildConfiguration.properties))
                    };
                }
            }
        }
        return liquidMap;
    }
    // --------------------------------------------------------------------------
    /**
     * Perform substitution on the input string.
     * Repeat until no more Liquid variables or tags are identified.
     *
     * @param input - The input string, possibly with substitutions.
     * @param map - The substitution map.
     * @returns The substituted string.
     *
     * @throws Liquid exceptions
     */
    async performSubstitutions(input, map) {
        assert(map);
        if (input === '') {
            // Spare it the trouble for empty strings.
            return input;
        }
        const log = this.log;
        let current = input;
        let substituted = current;
        // Iterate until all substitutions are done.
        while (current.includes('{{') || current.includes('{%')) {
            // May throw.
            substituted = await this.engine.parseAndRender(current, map);
            log.trace(`XpmLiquidMap.performSubstitutions(): '${substituted}'`);
            /* istanbul ignore next */
            if (substituted === current) {
                // If nothing changed, we're done.
                // Just a safety net, should not get there.
                /* istanbul ignore next */
                break;
            }
            current = substituted;
        }
        return substituted;
    }
}
exports.XpmLiquid = XpmLiquid;
// ----------------------------------------------------------------------------
//# sourceMappingURL=xpm-liquid.js.map