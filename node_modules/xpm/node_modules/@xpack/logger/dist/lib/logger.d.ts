/// <reference types="node" />
export declare type LogLevel = 'silent' | 'error' | 'warn' | 'info' | 'verbose' | 'debug' | 'trace' | 'all';
export declare type NumericLogLevel = number;
export interface LoggerParameters {
    level?: LogLevel;
    console?: Console;
}
export declare class Logger {
    static defaultLevel: LogLevel;
    /**
     * @summary Internal numerical values for the log level.
     */
    static numericLevels: {
        silent: number;
        error: number;
        warn: number;
        info: number;
        verbose: number;
        debug: number;
        trace: number;
        all: number;
    };
    /**
     * @summary The value used for the undefined log level (maximum value).
     */
    static numericLevelUndefined: NumericLogLevel;
    /**
     * @summary The value used for the always case (minimum value).
     */
    static numericLevelAlways: NumericLogLevel;
    private readonly _console;
    private _numericLevel;
    private _level;
    private _buffer;
    /**
     * @summary Create a logger instance for a given console.
     *
     * @param {LoggerParameters} params The generic params object.
     * @param {Console} params.console Reference to a console (an object with at
     *  least two functions, `log()` and `error()`)
     * @param {LogLevel} params.level A log level; may be undefined and set later.
     *
     * @description
     * If the log level is undefined, the logger is created in a preliminary
     * state, when all log lines will be stored in an internal buffer,
     * until the log level is known.
     *
     * If no `console` is given, the system `console` is used.
     */
    constructor(params?: LoggerParameters);
    get hasLevel(): boolean;
    /**
     * @summary Setter for the log level.
     *
     * @param {LogLevel} level The new log level.
     *
     * @description
     * If the log level is not one of the known strings, an assert will fire.
     * The first time the level is set, the internal buffer is flushed.
     */
    set level(level: LogLevel | undefined);
    /**
     * @summary Getter for the log level.
     *
     * @returns {LogLevel} The log level.
     */
    get level(): LogLevel | undefined;
    get isSilent(): boolean;
    get isError(): boolean;
    get isWarn(): boolean;
    get isInfo(): boolean;
    get isVerbose(): boolean;
    get isDebug(): boolean;
    get isTrace(): boolean;
    get isAll(): boolean;
    get console(): Console;
    /**
     * @summary Internal log writer.
     *
     * @param {NumericLogLevel} numericLevel The log numeric level.
     * @param {Function} loggerFunction The function to be used to write
     * the message.
     * @param {string} message The log message.
     * @returns {void} Nothing.
     *
     * @description
     * If the log level was defined, call the function, otherwise
     * store the log line details in the array buffer, for later
     * processing, when the log level is defined.
     *
     * @private
     */
    private write_;
    /**
     * @summary Output always.
     *
     * @param {string} msg Message.
     * @param {*} args Possible arguments.
     * @returns {void} Nothing.
     *
     * @description
     * The message is always passed to the console, regardless the
     * log level.
     *
     * Use this instead of console.log(), which in Node.js always
     * refers to the process console, not the possible REPL streams.
     */
    always(msg?: any, ...args: any[]): void;
    error(msg: Error): void;
    output(msg?: any, ...args: any[]): void;
    warn(msg?: any, ...args: any[]): void;
    info(msg?: any, ...args: any[]): void;
    verbose(msg?: any, ...args: any[]): void;
    debug(msg?: any, ...args: any[]): void;
    trace(msg?: any, ...args: any[]): void;
}
